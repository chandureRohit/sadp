{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Consolas;}{\f2\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue0;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs22\lang9 1. Write a Java Program to implement Singleton pattern for multithreading. \par
\b0 public class Main \{ \par
 public static void main(String ar[]) \{ \par
 Test1 t = new Test1(); \par
 Test1 t2 = new Test1(); \par
 Test1 t3 = new Test1(); \par
 Thread tt = new Thread(t); \par
 Thread tt2 = new Thread(t2);\par
Thread tt3 = new Thread(t3); \par
 Thread tt4 = new Thread(t); \par
 Thread tt5 = new Thread(t); \par
 tt.start(); \par
 tt2.start(); \par
 tt3.start(); \par
 tt4.start(); \par
 tt5.start(); \par
 \} \par
\} \par
final class Test1 implements Runnable \{ \par
 @Override \par
 public void run() \{ \par
 for (int i = 0; i < 5; i++) \{ \par
 System.out.println(Thread.currentThread().getName() + " : " + \par
Single.getInstance().hashCode()); \par
 \} \par
 \} \par
\} \par
 \par
class Single \{ \par
 private final static Single sing = new Single(); \par
private Single() \{ \par
 \} \par
 public static Single getInstance() \{ \par
 return sing; \par
 \} \par
 \} \par
\b o/p - \cf1\f1\fs20 Thread-1 : 13362967\cf0\par
\cf1 Thread-0 : 13362967\cf0\par
\cf1 Thread-0 : 13362967\cf0\par
\cf1 Thread-0 : 13362967\cf0\par
\cf1 Thread-0 : 13362967\cf0\par
\cf1 Thread-0 : 13362967\cf0\par
\cf1 Thread-3 : 13362967\cf0\par
\cf1 Thread-3 : 13362967\cf0\par
\cf1 Thread-3 : 13362967\cf0\par
\cf1 Thread-2 : 13362967\cf0\par
\cf1 Thread-2 : 13362967\cf0\par
\cf1 Thread-2 : 13362967\cf0\par
\cf1 Thread-2 : 13362967\cf0\par
\cf1 Thread-2 : 13362967\cf0\par
\cf1 Thread-4 : 13362967\cf0\par
\cf1 Thread-3 : 13362967\cf0\par
\cf1 Thread-3 : 13362967\cf0\par
\cf1 Thread-1 : 13362967\cf0\par
\cf1 Thread-1 : 13362967\cf0\par
\cf1 Thread-4 : 13362967\cf0\par
\cf1 Thread-4 : 13362967\cf0\par
\cf1 Thread-4 : 13362967\cf0\par
\cf1 Thread-1 : 13362967\cf0\par
\cf1 Thread-4 : 13362967\cf0\par
\cf1 Thread-1 : 13362967\par
\b0\par
\b\f2\lang16393 2. Lower case decorator pattern\par
\b0 import java.io.*; \par
import java.util.*; \par
 class LowerCaseInputStream extends FilterInputStream \par
 \{ \par
 public LowerCaseInputStream(InputStream in) \{ \par
 super(in); \par
 \} \par
 public int read() throws IOException \{ \par
 int c = super.read(); \par
 return (c == -1 ? c : Character.toLowerCase((char)c)); \par
 \} \par
 public int read(byte[] b, int offset, int len) throws IOException \{ \par
 int result = super.read(b, offset, len); \par
 for (int i = offset; i < offset+result; i++) \{ \par
 b[i] = (byte)Character.toLowerCase((char)b[i]); \par
 \} \par
 return result; \par
 \} \par
\} \par
public class Main \{ \par
 public static void main(String[] args) throws IOException \par
int c; \par
 try \{ \par
 InputStream in = \par
 new LowerCaseInputStream( \par
 new BufferedInputStream( \par
 new FileInputStream("test.txt"))); \par
 while((c = in.read()) >= 0) \{ \par
 System.out.print((char)c); \par
 \} \par
 in.close(); \par
 \} catch (IOException e) \{ \par
 e.printStackTrace(); \par
 \} \par
 \} \par
\} \par
\b o/p - abcde\par
\par
3. Factory pattern shape program\par
Create an interface.\par
Shape.java\par
\b0 public interface Shape \{\par
   void draw();\par
\}\par
\par
\b Rectangle.java\b0\par
public class Rectangle implements Shape \{\par
   @Override\par
   public void draw() \{\par
      System.out.println("Inside Rectangle::draw() method.");\par
   \}\par
\}\par
\par
\b Square.java\par
\b0 public class Square implements Shape \{\par
   @Override\par
   public void draw() \{\par
      System.out.println("Inside Square::draw() method.");\par
   \}\par
\}\par
\par
\b Circle.java\b0\par
public class Circle implements Shape \{\par
   @Override\par
   public void draw() \{\par
      System.out.println("Inside Circle::draw() method.");\par
   \}\par
\}\par
\par
\b ShapeFactory.java\par
\b0 public class ShapeFactory \{\par
   //use getShape method to get object of type shape \par
   public Shape getShape(String shapeType)\{\par
      if(shapeType == null)\{\par
         return null;\par
      \}\tab\tab\par
      if(shapeType.equalsIgnoreCase("CIRCLE"))\{\par
         return new Circle();\par
         \par
      \} else if(shapeType.equalsIgnoreCase("RECTANGLE"))\{\par
         return new Rectangle();\par
         \par
      \} else if(shapeType.equalsIgnoreCase("SQUARE"))\{\par
         return new Square();\par
      \}\par
      return null;\par
   \}\par
\}\par
\par
\b FactoryPatternDemo.java\b0\par
public class FactoryPatternDemo \{\par
   public static void main(String[] args) \{\par
      ShapeFactory shapeFactory = new ShapeFactory();\par
\par
      //get an object of Circle and call its draw method.\par
      Shape shape1 = shapeFactory.getShape("CIRCLE");\par
\par
      //call draw method of Circle\par
      shape1.draw();\par
\par
      //get an object of Rectangle and call its draw method.\par
      Shape shape2 = shapeFactory.getShape("RECTANGLE");\par
\par
      //call draw method of Rectangle\par
      shape2.draw();\par
\par
      //get an object of Square and call its draw method.\par
      Shape shape3 = shapeFactory.getShape("SQUARE");\par
\par
      //call draw method of square\par
      shape3.draw();\par
   \}\par
\}\par
\par
\b o/p -  Inside Circle::draw() method.\par
\tab Inside Rectangle::draw() method.\par
\tab Inside Square::draw() method.\par
\par
4. Adapter pattern Bird program\par
\b0 // Java implementation of Adapter pattern\par
interface Bird\par
\{\par
\tab // birds implement Bird interface that allows\par
\tab // them to fly and make sounds adaptee interface\par
\tab public void fly();\par
\tab public void makeSound();\par
\}\par
\par
class Sparrow implements Bird\par
\{\par
\tab // a concrete implementation of bird\par
\tab public void fly()\par
\tab\{\par
\tab\tab System.out.println("Flying");\par
\tab\}\par
\tab public void makeSound()\par
\tab\{\par
\tab\tab System.out.println("Chirp Chirp");\par
\tab\}\par
\}\par
\par
interface ToyDuck\par
\{\par
\tab // target interface\par
\tab // toyducks dont fly they just make\par
\tab // squeaking sound\par
\tab public void squeak();\par
\}\par
\par
class PlasticToyDuck implements ToyDuck\par
\{\par
\tab public void squeak()\par
\tab\{\par
\tab\tab System.out.println("Squeak");\par
\tab\}\par
\}\par
\par
class BirdAdapter implements ToyDuck\par
\{\par
\tab // You need to implement the interface your\par
\tab // client expects to use.\par
\tab Bird bird;\par
\tab public BirdAdapter(Bird bird)\par
\tab\{\par
\tab\tab // we need reference to the object we\par
\tab\tab // are adapting\par
\tab\tab this.bird = bird;\par
\tab\}\par
\par
\tab public void squeak()\par
\tab\{\par
\tab\tab // translate the methods appropriately\par
\tab\tab bird.makeSound();\par
\tab\}\par
\}\par
\par
class Main\par
\{\par
\tab public static void main(String args[])\par
\tab\{\par
\tab\tab Sparrow sparrow = new Sparrow();\par
\tab\tab ToyDuck toyDuck = new PlasticToyDuck();\par
\par
\tab\tab // Wrap a bird in a birdAdapter so that it\par
\tab\tab // behaves like toy duck\par
\tab\tab ToyDuck birdAdapter = new BirdAdapter(sparrow);\par
\par
\tab\tab System.out.println("Sparrow...");\par
\tab\tab sparrow.fly();\par
\tab\tab sparrow.makeSound();\par
\par
\tab\tab System.out.println("ToyDuck...");\par
\tab\tab toyDuck.squeak();\par
\par
\tab\tab // toy duck behaving like a bird\par
\tab\tab System.out.println("BirdAdapter...");\par
\tab\tab birdAdapter.squeak();\par
\tab\}\par
\}\par
\par
\b o/p -  Sparrow...\par
\tab Flying\par

\pard\li720\sa200\sl276\slmult1 Chirp Chirp\par
ToyDuck...\par
Squeak\par
BirdAdapter...\par
Chirp Chirp\cf0\f0\fs22\lang9\par
}
 